# c++ 知识点汇总
***

***
### c++四种cast转换
static_cast 转换
用于非多态类型转换，安全性不如dynamic转换，父类转子类不安全。
最常用转换，是c++传统强制转换替代品，但不会转换掉const、volitale、或者__unaligned属性。

dynamic_cast转换
只能用于带有虚函数的类，T必须是类的指针，类的引用或者void*，通常应用于上行转换（子类-子类/基类）和下行转换（基类-子类）具备类型检查功能，更加安全。对不明确的指针的转换将失败（返回 nullptr），但不引发异常

reinterpret_cast重述转换
为数据的二进制形式重新解释，但是不改变其值。
T必须是一个指针、引用、算术类型、函数指针或者成员指针。
一般将整型转为一个指针或把指针转为整型，较危险，一般不用。

const_cast 转换
T需为指针和引用，通常用于去掉const，volatile 和 __unaligned 属性。
***
### volatile 关键字，多线程用同一个变量需要使用volatile，防止优化编译器将变量从内存装入cpu寄存器，从而引发错误使用。
### const的指针与引用
指针：指向常量的指针和自身是常量的指针
引用：指向常量的引用
修饰普通变量，使变量存储在静态区
修饰普通函数，仅在定义该函数的作用范围
修饰成员变量，使所有对象只保存一个该变量
修饰成员函数，在static函数不能访问非静态成员。
###this指针， 隐含于每一个非静态成员函数的特殊指针，指向函数对象。
###inline内联函数
在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。
类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联

优点：提升运行速度，相比宏会做安全检查和类型转换，内联函数可以访问类的成员变量，在运行时可调试，宏不行。
缺点：消耗更多内存空间，是否内联取决于编译器。
通常十行以下，不包含循环和switch
###结构体大小
指针按照32/64区分，数组算一个，嵌套结构体按照嵌套结构体内部算大小
###new对象与不new区别
[](https://blog.csdn.net/tham_/article/details/44906571)
###
c++有三种继承public，protected，private，其中有两点没变：
1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；

2.protected 成员可以被派生类访问。
###封装继承多态

面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！

继承分为实现继承，接口继承，可视继承。
《Effective C++》条款三十四：区分接口继承和实现继承中介绍的比较啰嗦，概括地说需要理解三点：
（1）纯虚函数只提供接口继承，但可以被实现；
（2）虚函数既提供接口继承，也提供了一份默认实现，即也提供实现继承；
（3）普通函数既提供接口继承，也提供实现继承。

重载只是一种语言特性，与多态无关，与面向对象也无关！
多态是以封装和继承为基础的。

C++ 多态分类及实现：
重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
子类型多态（Subtype Polymorphism，运行期）：虚函数
参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

普通函数（非类成员函数）不能是虚函数
静态函数（static）不能是虚函数
构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
内联函数不能是表现多态性时的虚函数，

虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。

###


xxx

***
### explicit（显式）关键字
explicit 修饰构造函数时，可以防止隐式转换和复制初始化
explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外
###左右值引用
在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。
左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。
int &a = 2;       # 左值引用绑定到右值，编译失败
 
int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
链接[](https://blog.csdn.net/qianyayun19921028/article/details/80875002)

###如何定义一个只能在堆上（栈上）生成对象的类？

只能在堆上
方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

只能在栈上
方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。