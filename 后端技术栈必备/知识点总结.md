知识点总结：
***
# C++
cast四种类型总结
static cast 非多态类型转换（不执行运行时类型检查）
dynamic cast 多态类型转换
const cast 删除const特性
reinterpret_cast 任意转换

RAII机制 资源获取初始化，可以使用RAII将网络套接字，互斥锁等资源进行管理实现自动内存管理，避免内存泄漏。使用动态指针实现RAII机制

动态指针：保证自动正确的销毁动态分配的对象。
1. shared_ptr 多指针引用同一对象，基于引用计数
需要记住的事，在以下三种情况下会引起引用计数的变更：

调用构造函数时： SmartPointer p(new Object());
赋值构造函数时： SmartPointer p(const SmartPointer &p);
赋值时：SmartPointer p1(new Object()); SmartPointer p2 = p1;

2. weak_ptr 只引用不计数，多指针循环引用需要用weak_ptr
3. unique_ptr 独占指针，只能有一个指针占用对象，资源转移使用move

move 将左值引用转换为右值引用，称为移动语义。

右值引用和左值引用：
左值引用是对象别名，要求右边的值能取地址，无法取可以用const
右值引用通常是立即数，函数返回值，与常引用不同可以读写，常引用只能读。
左引用：有名字，可取地址，非临时
右引用：不能取地址，无名字，临时
右引用作用：1 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。2 能够更简洁明确地定义泛型函数。（属性和参数值）
带右引用的叫移动构造函数和移动赋值函数，不带的叫拷贝构造函数，赋值重载函数。

c++11新特性：
auto关键字：自动类型推导
lambda表达式：auto add = [](int a, int b) {return a + b};
右值引用和移动语义
~~多线程编程~~
~~mutex, condition_variable等同步原语以及future关键字的使用~~

堆和栈区别
1. 栈系统自动分配，堆主动申请
2. 生长方向：栈向下，堆向上（向内存地址增加方向）
3. 栈存储局部变量，函数参数；堆存储new分配的内存块
4. 堆会产生碎片
5. 栈效率高，堆效率低
6. 堆的优点是使用灵活，容量大
7. 堆动态分配，栈动静态分配

malloc free和new delete区别
1. new会调用构造函数，malloc不会
2. new失败返回bad_alloc错误码，malloc返回NULL
3. new自动分配大小，malloce指定分配大小
4. new返回对象类型指针，安全，malloc返回void*强制转换类型
5. new有数组版本[],malloc*n
6. new底层实现malloc
malloc free用于分配、释放内存
申请内存，确认是否申请成功
char *str = (char*) malloc(100);
assert(str != nullptr);
释放内存后指针置空
free(p); 
p = nullptr;
new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}

C++的内存布局：内存区分为5个区，分别是堆、栈、自由存储区（new，delete）、全局/静态存储区、常量存储区

static 用来控制变量的存储方式和可见性。成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。
1. 修饰普通变量 修改变量存储区和生命周期，变量在静态存储区
2. 修饰普通函数，函数只能在本文件使用，防多人重名
3. 修饰成员变量，任何成员均可访问，只保存一个变量
4. 修饰成员函数，不需要生成对象即可访问，不能访问非静态成员

c++中struct和class区别
struct是数据结构的实现体，class是对象实现体
struct默认public，class默认private

面向对象三大特性
封装，继承，多态
封装：将客观事物封装成抽象的类，将数据和方法只让可信的类和对象操作，对不可信进行隐藏
继承：子类复用父类代码，提高代码重用性（菱形继承会用到虚拟继承）
多态：一个接口多种方法，据指向的子类的不同而调用不同的方法。虚函数（运行多态），后三个函数重载（编译），函数模板（编译），类型转换（编译/运行）

虚函数virtual
静态函数不能是虚函数，因为虚函数和类对象捆绑
构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
析构函数会是虚函数，否则delete时，不会调用子类析构函数，造成内存泄漏
内联函数不能是表现多态性时的虚函数（内联函数编译运行）
模板类可以有虚函数，模板成员函数不可以是虚函数（模板成员函数静态编译）
纯虚函数 virtual int A() = 0;关注接口统一性
虚函数可以在子类不重写，但纯虚函数需要子类实现才可以实例化子类

虚基类是虚继承中的基类（菱形继承）
虚继承
虚基类依旧存在继承类中，只占用存储空间
虚基类表存储的是虚基类相对直接继承类的偏移
虚函数
虚函数不占用存储空间
虚函数表存储的是虚函数地址
[](https://kangcai.github.io/2019/08/27/interview-lang-c++-virtual/)
[](https://blog.csdn.net/DoronLee/article/details/78112300)

c++程序编译过程
预处理：处理头文件，宏
编译：将文件翻译成汇编程序
汇编：将汇编程序翻译成机器语言
链接：将目标文件链接生成可执行文件

***
# 操作系统
线程与进程区别
进程是资源分配基本单位
线程是cpu调度基本单位
进程资源开销较大，每个进程有独立代码及空间
线程是轻量级进程，同类线程共享代码及空间，线程有自己独立运行栈及程序计数器（记录程序执行位置）
同一进程可包含多个线程
多进程比多线程健壮
多进程内存占用高，切换复杂，cpu利用率低
多线程内存占用少，切换简单，cpu利用率高

进程之间私有和共享资源
私有：地址空间，堆，全局变量，栈，寄存器
共享：代码段，公共数据，进程目录和ID
线程之间私有和共享资源
私有：线程栈，寄存器，程序计数器
共享：堆，地址空间，全局变量，静态变量

进程之间通信方式：
管道：有名管道，无名管道-半双工通信（区别是有名允许无亲缘关系进程通信）
信号量：计数器，


缓存淘汰算法LRU和LFU
LRU 最近最少使用 淘汰访问时间最旧的
LFU 最近不经常使用 淘汰频次最低的






