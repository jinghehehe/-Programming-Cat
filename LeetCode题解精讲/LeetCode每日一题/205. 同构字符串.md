# 205. 同构字符串
***
来源： LeetCode 每日一题 20/12/27
相关企业： 亚马逊，苹果
相关标签： 哈希表
难度： 简单
***
## 题干内容
给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例 1:

![](https://github.com/jinghehehe/pictures/blob/main/205-1.png)
 
示例 2:


![](https://github.com/jinghehehe/pictures/blob/main/205-2.png)

示例 3:

![](https://github.com/jinghehehe/pictures/blob/main/205-3.png)

说明:
你可以假设 s 和 t 具有相同的长度。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/isomorphic-strings
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 题眼题解
### 题眼:
**可以看出本题可以采用哈希表来做，**

### 题解：
#### c++版本一，时间复杂度 O(nlogn), 空间复杂度 O(logn)。//排序开销
```language
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int glen = g.size();
        int slen = s.size();
        int i=0, j=0, count=0;
        while(i<glen && j<slen){
            if(g[i] <= s[j]){
                count++;
                i++;
                j++;
            }
            else {
                j++;
            }
        }
        return count;
    }
};
```
#### python3版本一，时间复杂度 O(nlogn), 空间复杂度 O(logn)。
```language
# 与c++版本一相同。
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        glen = len(g)
        slen = len(s)
        gi = si = count = 0
        while gi<glen and si<slen:
            if g[gi] <= s[si]:
                gi+=1
                si+=1
                count+=1
            else:
                si+=1
        return count
```
***

### **喜欢Programming-Cat的话，请Star吧**



